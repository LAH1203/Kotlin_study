<변수 선언 방법>
변수를 선언하기 위해서는 val, var을 사용해야 한다. 만약 사용할 변수의 값이 변경되지 않아야 한다면(const) val, 변경되어야 한다면 var을 사용하여 변수를 선언하면 된다.
- val(value) : 불변형
- var(variable) : 가변형

<변수 선언 형태>
(ex) val username: String = "Ahhyun"    // 가장 충실한 기본 형태
(ex) var count = 3    // 자료형을 추론하여 int로 결정(타입 생략 가능)
(ex) val init: Int    // 사용 전 혹은 생성자 시점에서 변수 초기화가 필요
(ex) var username     // 사용 불가 예시, 자료형을 지정하지 않은 변수는 사용할 수 없다.

<변수명 주의사항>
- 변수 이름은 123abc와 같이 숫자로 시작하는 것은 불가능하다.
- 변수 이름에는 while, if와 같이 코틀린에서 사용되는 키워드는 사용할 수 없다.
- 변수 이름은 의미 있는 단어를 사용하여 만드는 것이 좋다.
- 여러 단어를 사용하여 변수 이름을 지울 경우 카멜 표기법을 사용하는 것이 좋다.

! 코틀린은 참조형 자료형을 사용
  - 보통 프로그래밍 언어의 자료형은 기본형 자료형과 참조형 자료형으로 구분하며 코틀린은 참조형 자료형을 사용한다.
  - 기본형(Primitive data type)
    + 가공되지 않은 순수한 자료형으로 프로그래밍 언어에 내장
    + int, long, float, double 등
  - 참조형(Reference type)
    + 동적 공간에 데이터를 둔 다음 이것을 참조하는 자료형
    + Int, Long, Float, Double 등

<정수 자료형>
정수 자료형은 양수, 음수, 0을 나타낸다. 코틀린의 정수 자료형은 부호가 있는 것과 부호가 없는 것으로 나눌 수 있다. 숫자크기에 상관없이 기본은 모두 Int형으로 추론된다.

<실수 자료형>
실수 자료형은 실수를 저장하기 위해 사용한다. 정수와 마찬가지로 실수도 자료형을 명시하지 않으면 Double형으로 추론된다.
만약 Float형으로 지정하고 싶다면, 간략하게 식별자 F를 실수 옆에 붙이거나 변수 생성시 자료형을 명시해주면 된다.
실수의 개수는 무한하나 메모리 공간은 유한하기 때문에 메모리에 모든 실수를 표현하기는 어렵다. 때문에 실수를 표현할 때 부동 소수점 방식(floating-point)을 사용한다. 부동 소수점 방식은 실수를 가수, 지수로 나누어 표현하는 방식이다.
(ex) 3.14 X 10^16 -> 3.14E+16
(ex) val exp1 = 3.14E-2   // 왼쪽으로 소수점 2칸 이동, 0.0314
(ex) val exp2 = 3.14e2    // 오른쪽으로 소수점 2칸 이동, 314

<자료형 사용 예시>
- 자료형 생략
  (ex) val num1 = 127   // Int형으로 추론
  (ex) val num2 = -32768  // Int형으로 추론
  (ex) val num3 = 2147483647  // Int형으로 추론
  (ex) val num4 = 9223372036854775807   // Long형으로 추론
- 접미사 접두사 사용
  (ex) val exp1 = 123   // Int형으로 추론
  (ex) val exp2 = 123L  // 접미사 L을 사용해 Long형으로 추론
  (ex) val exp3 = 0x0F  // 접두사 0x를 사용해 16진 표기가 사용된 Int형으로 추론, 15
  (ex) val exp4 = 0b00001011    // 접두사 0b를 사용해 2진 표기가 사용된 Int형으로 추론, 11
- 작은 값의 사용
  (ex) val exp5: Byte = 127   // 명시적으로 자료형을 지정(Byte)
  (ex) val exp6 = 32767   // 명시적으로 자료형을 지정하지 않으면 Short형 범위의 값도 Int형으로 추론
  (ex) val exp7: Short = 32767    // 명시적으로 자료형을 지정(Short)
- 부호 없는 정수 자료형
  (ex) val uint: UInt = 153u
  (ex) val ushort: UShort = 65535u
  (ex) val ulong: ULong = 46322342uL
  (ex) val ubyte: UByte = 255u
- 큰 수를 읽기 쉽게 하는 방법
  + 읽기 쉽게 하기 위해 언더스코어(_)를 포함해 표현
  + (ex) val number = 1_000_000
  + (ex) val cardNum = 1234_1234_1234_1234L
  + (ex) val hexVal - 0xAB_CD_EF_12
  + (ex) val bytes = 0b1101_0010

<논리 자료형>
참, 거짓을 표현하는 논리 자료형은 조건을 검사할 때 많이 사용한다.
+ Boolean - true(참),false(거짓)

<문자 자료형>
문자 자료형(Char)은 문자를 표현하기 위해 사용하며 문자 자료형의 값은 작은따옴표(')로 감싸 표현한다.
컴퓨터는 문자 자료형의 값을 저장할 때 문자 세트(아스키코드 표, 유니코드 표)를 참고하여 번호로 저장한다. 예를 들어, 컴퓨터에는 문자 a가 a로 저장되는 것이 아니라 65로 저장된다. 쉽게 말해 컴퓨터는 문자 a를 65로 이해한다.
단, 코틀린에서 문자 자료형을 선언할 때만큼은 문자값으로 선언해야 한다. 선언한 다음에는 문자 자료형에 숫자를 더하는 방식으로 다른 문자를 표현할 수 있다.
+ Char - 2바이트(16비트)

<문자열 자료형>
문자열 자료형은 문자 자료형에서 더 나아가 여러 문자를 배열하여 저장할 수 있는 자료형이다.
문자 자료형과 따로 다루는 이유는 문자형인 Char은 char과 같은 기본형으로 처리되지만, 문자열 자료형은 기본형에 속하지 않는 배열 형태로 되어 있는 특수한 자료형이기 때문이다.
문자열은 힙 메모리 영역의 String Pool이라고 부르는 공간에 문자열을 저장해두고 이 값을 변수에서 참조한다.
+ String(String Pool 공간에 구성)

! 변수의 값이나 표현식을 문자열 안에 넣어 출력하려면 달러 기호($)와 함께 변수나 표현식을 사용하면 된다.

<Non-null 타입과 nullable 타입>
프로그램이 실행되는 도중에 값이 null인 변수에 접근하려 하면 NPE(NullPointerException) 오류가 발생한다. 변수에 null 할당을 허용하려면 자료형 뒤에 물음표 기호(?)를 명시해야 한다.
null 허용 여부에 따라서 예를 들면 String과 String?으로 나누어 명시할 수 있다. 둘은 엄연히 서로 다른 자료형임을 명시하자!

<세이프 콜>
세이프 콜이란 null이 할당되어 있을 가능성이 있는 변수를 검사하여 안전하게 호출하도록 도와주는 연산자로 사용할 변수 이름 뒤에 ?.를 작성하면 된다.
  - (ex) println("str1: $str1 length: ${str1?.length}")   // str1을 세이프 콜로 안전하게 호출
non-null 단정 기호(!!.)는 null이 아님을 단정하므로 컴파일러가 null 검사 없이 무시한다. 따라서 null이 할당되어 있을지라도 컴파일은 잘 진행되지만 실행 중에는 NPE를 발생시킨다. 따라서 되도록이면 사용하지 않는 것이 좋으니 반드시 null이 아니라는 것이 보장될 때만 사용하자!
null을 허용한 변수를 조금 더 안전하고 간단하게 사용하려면 세이프 콜(?.)과 엘비스 연산자(?:)를 함께 사용하면 된다. 엘비스 연산자는 변수가 null인지 아닌지 검사하여 null이 아니라면 왼쪽의 식을, null이라면 오른쪽의 식을 실행한다.
  - (ex) val len = str?.length ?: -1    // str이 null이 아니면 문자열 길이가, null이면 -1이 len에 들어간다.

<자료형 변환이 필요한 이유>
코틀린의 자료형은 모두 참조형으로 선언한다. 하지만 컴파일을 거쳐서 최적화될 때는 Int, Long, Short와 같은 참조형 자료형은 int, long, short같은 기본형 자료형으로 변환된다.
참조형과 기본형의 저장방식은 서로 다르기 때문에 자료형을 비교하거나 검사할 때는 이와 같은 특징을 이해하고 있어야 한다.
! 코틀린에서는 자료형이 다른 변수에 재할당되면 자동형변환이 되지 않고 자료형 불일치 오류가 발생한다.
  - (ex) val a: Int = 1   // 정수형 변수 a를 선언하고 1을 할당
  - (ex) val b: Double = a    // 자료형 불일치 오류 발생
  - (ex) val c: Int = 1.1     // 자료형 불일치 오류 발생
  - 변수 a는 정수형이므로 실수형 변수 b에 다시 할당할 수 없다. 물론 정수형 자료형인 c에 1.1을 대입하는 것도 안 된다. 만일 자료형을 변환해 할당하고 싶다면 코틀린에서는 자료형 변환 메소드를 사용해야 한다.
    + toByte : Byte
    + toLong : Long
    + toShort : Short
    + toFloat : Float
    + toInt : Int
    + toDouble : Double
    + toChar : Char
  - 그러므로 두 번째 예시는 val b: Double = a.toDouble()로 바뀌면 옳다.

<표현식에서 자료형의 자동 형 변환>
(ex) val result = 1L + 3    // Long + Int -> Long

<기본형과 참조형 자료형의 비교>
자료형을 비교할 때는 단순히 값만 비교하는 방법과 참조 주소까지 비교하는 방법이 있다. 단순히 값만 비교할 때는 이중 등호(==)를 사용하고 참조 주소를 비교하려면 삼중 등호(===)를 사용한다.
이중 등호는 참조에 상관없이 값이 동일하면 true를, 값이 다르면 false를 반환한다. 삼중 등호는 값과 상관없이 참조가 동일하면 true를 반환한다.

<is 키워드>
is 키워드를 사용하면 자료형이 무엇인지를 판단할 수 있다.
(ex) num is Int   // num이 Int형일 경우 true 반환
(ex) num !is Int  // num이 Int형이 아닐 경우 true 반환, !(num is Int)와 동일

<스마트 캐스트>
만약 어떤 값이 정수일 수도 있고, 실수일 수도 있다면 그 때마다 새로운 변수를 생성하는 것보다 좋은 방법이 있다. 바로 Number형을 사용하는 것이다.
Number형은 자료형의 한 종류로써, 이를 사용하면 숫자를 저장하기 위한 특수한 자료형 객체로 만들 수 있다. Number형으로 정의된 변수에는 저장되는 값에 따라 정수, 실수 등으로 자료형이 변환된다. 즉, Number은 상위 자료형에 속하는 것이다.
이와 같이 상위 자료형은 하위 자료형을 모두 포함하므로 하위에 속하는 어떤 자료형으로도 변환 가능하다. 다만 String은 Number에 속하지 않으므로 이 점 유의!

<묵시적 형 변환>
Any형은 자료형이 특별히 정해지지 않은 경우에 사용한다. 코틀린의 Any형은 모든 클래스의 뿌리이다. 우리가 자주 사용한 Int나 String, 그리고 사용자가 직접 만든 클래스까지 모두 Any형의 자식 클래스이다.
즉, 코틀린의 모든 클래스는 바로 이 Any형이라는 슈퍼 클래스(Superclass)를 가지는 것이다. 따라서 Any를 사용해 변수를 선언하면 해당 변수는 어떤 형으로도 변환할 수 있게 된다.(스마트 캐스트)

<산술 연산자>
사칙연산에 사용되는 사칙 연산자(+, -, *, /)와 나머지 연산자(%)를 산술 연산자라 부른다.

<대입 연산자>
대입 연산자(=)는 변수에 값을 할당하는 연산자이다. 그리고 대입 연산자는 이항 연산자 중 우선순위가 가장 낮다. 즉, 다른 연산자의 연산이 모두 끝나야 대입 연산자가 동작할 수 있는 것이다.

<증감 연산자>
증가 연산자와 감소 연산자는 항이 1개인 단항 연산자이다. 증가, 감소 연산자는 항의 앞이나 뒤에 붙여 사용하며 이름 그대로 1을 더하거나 빼는 연산을 수행한다.

<비교 연산자>
비교 연산자는 두 개의 항을 비교하기 위해 사용한다. 모든 비교 연산자는 비교 결과가 참이면 true를, 거짓이면 false를 반환한다.

<논리 연산자>
논리 연산자에는 논리곱 연산자, 논리합 연산자, 부정 연산자가 있다.
논리곱 연산자(&&)는 2개의 항이 모두 true인 경우에만 true를 반환하고 논리합 연산자(||)는 2개의 항 중에 1개의 항만 true이면 true를 반환한다. 부정 연산자(!)는 true와 false의 값을 반대로 바꾼다.

<비트 연산자>
비트 연산자는 기계가 이해할 수 있는 값인 0과 1을 처리하는데 사용한다. 비트 연산자는 프로그래머가 기기를 직접 제어해야 하는 경우 아주 유용하게 사용된다.
보통 IoT 기기를 위한 컨트롤러를 접근하거나 프로세서의 레지스터에 접근하는 임베디드 시스템 프로그래밍 분야에서 비트 연산을 사용한다.

<비트 메소드>
비트 메소드는 메소드처럼 사용해도 되지만 연산자처럼 사용할 수 있다. 예를 들어, 비트 전체를 왼쪽으로 이동시키는 shl 메소드는 4.shl(1) 또는 4 shl 1과 같은 방법으로 사용할 수 있다.
(ex) 4.shl(bits)  // 4를 표현하는 비트를 bits만큼 왼쪽으로 이동(부호 있음)
(ex) 7.shr(bits)  // 7을 표현하는 비트를 bits만큼 오른쪽으로 이동(부호 있음)
(ex) 12.ushr(bits)  // 12를 표현하는 비트를 bits만큼 오른쪽으로 이동(부호 없음)
(ex) 9.and(bits)  // 9를 표현하는 비트와 bits를 표현하는 비트로 논리곱 연산
(ex) 4.or(bits)  // 4를 표현하는 비트와 bits를 표현하는 비트로 논리합 연산
(ex) 24.xor(bits)  // 24를 표현하는 비트와 bits를 표현하는 비트의 배타적 연산
(ex) 78.inv  // 78을 표현하는 비트를 모두 


